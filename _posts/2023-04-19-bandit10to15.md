---
layout: post
title: Bandit level 10 to 15 - Walkthrough
date: "2023-04-19 23:09:00 +0000"
categories: [CTF-WRITEUPS, OverTheWire- Bandit]
tags: [linux, bandit]
---

## Level 10 --> 11

### Level credentials

- username : **<span style="color : #277BE9">bandit10</span>**
- password : **<span style="color : #277BE9">G7w8LIi6J3kTb8A7j9LgrywtEUlyyp6s</span>**

### Level goal

The password for the next level is stored in the file data.txt, which contains base64 encoded data

### Level solution

When we `cat` the content of data.txt, we obtain the following string :

> VGhlIHBhc3N3b3JkIGlzIDZ6UGV6aUxkUjJSS05kTllGTmI2blZDS3pwaGxYSEJNCg==

Now, this is a base64 encoded string.

Base64 encoding is a method to represent binary data as ASCII characters using a set of 64 characters. It is commonly used for transmitting data over channels designed for text only. It is a reversible process allowing the original binary data to be recovered.

We can easily decode our string using `base64` linux command with `-d` option, but where is the fun doing that?

Let's create our own **<span style="color : #277BE9">python</span>** script that will decrypt the password.

You can read [this article](https://medium.com/swlh/base64-encoding-algorithm-42abb929087d) that explains base64 encoding very well.

Once you have read the article, you can check the script i wrote in my github [here](https://github.com/y4riss/b64/blob/main/b64.py).

```python
import sys

# creating base64 table index
A_Z = [chr(i) for i in range(65,91)]
a_z = [chr(i) for i in range(97,123)]
zero_nine = [chr(i) for i in range(48,58)]
additional_chars = ['+','/']
base64_index_table = A_Z + a_z + zero_nine + additional_chars

# binary to decimal custom function
def bin_to_int(byte):
        #110101
        result = 0
        for i in range(0,len(byte)):
            result += int(byte[len(byte) - 1 - i]) * pow(2 ,i)
        return result

def b64_encode(word):

    # converting the word into its binary format
    binary = []
    for c in word:
        binary.append(bin(ord(c)).split("b")[-1].rjust(8,'0'))

    binary = "".join(binary)

    # splitting the binary format into chunks of 6 bits
    new_word = []

    while len(binary):
        new_word.append(binary[0:6])
        binary = binary[6:]

    # adding padding to the last elem
    new_word[-1] = new_word[-1].ljust(6, '0')


    # encrypting the text
    result = ""
    for byte in new_word:
        result += base64_index_table[bin_to_int(byte)]

    # adding padding of "="
    def get_multiple_of_4(num):

        while num % 4 != 0:
            num += 1
        return num
    result = result.ljust(get_multiple_of_4(len(result)),'=')
    return result


def b64_decode(word):

    #stripping away '='
    word = word.split("=")[0]

    #find index of each character in b64_index_table
    indexes = []
    for c in word:
        indexes.append(base64_index_table.index(c))

    # index to binary ( 6 bits)
    binary = []
    for i in indexes:
        binary.append(bin(i).split("b")[-1].rjust(6,'0'))

    binary = "".join(binary)
    # form group of 8 bits
    new_word = []
    while len(binary):
        new_word.append(binary[0:8])
        binary = binary[8:]

    # transform each byte to its ascii representation
    result = ""
    for c in new_word:
        result += chr(bin_to_int(c))
    return result

#python b64.py
if __name__ == '__main__':

    len_args = len(sys.argv)
    if (len_args != 3):
        print(f"[] Usage : python {sys.argv[0]} <string> (-d | -e )")
        exit(0)
    option = sys.argv[2]
    if (option != '-d' and option != '-e'):
        print(f"[] Usage : python {sys.argv[0]} <string> (-d | -e )")
        exit(0)

    word = sys.argv[1]
    if (option == '-d'):
        print(f"[+] {word} ---> {b64_decode(word)}")
    else:
        print(f"[+] {word} ---> {b64_encode(word)}")
```

```bash
python b64.py 'VGhlIHBhc3N3b3JkIGlzIDZ6UGV6aUxkUjJSS05kTllGTmI2blZDS3pwaGxYSEJNCg==' -d
```

![img](/../assets/bandit11-1.png)
![img](/../assets/bandit11-2.png)

We got our password ðŸ˜ƒ

> 6zPeziLdR2RKNdNYFNb6nVCKzphlXHBM

## Level 11 --> 12

### Level credentials

- username : **<span style="color : #277BE9">bandit11</span>**
- password : **<span style="color : #277BE9">6zPeziLdR2RKNdNYFNb6nVCKzphlXHBM</span>**

### Level goal

The password for the next level is stored in the file data.txt, where all lowercase (a-z) and uppercase (A-Z) letters have been rotated by 13 positions

### Level solution

Basically, each letter of our password is rotated 13 times, meaning that 'a' becomes 'n' , 'b' becomes 'o' , ...

```bash
cat data.txt
```

> Gur cnffjbeq vf WIAOOSFzMjXXBC0KoSKBbJ8puQm5lIEi

Let's create a simple c program to decrypt our password

```c
#include<stdio.h>
#include<string.h>

int main(int ac, char **av)
{
        if (ac != 2)
                return 0;

        char *word = av[1];
        for(size_t i = 0 ; i < strlen(word) ; i++)
        {
                char c = word[i];
                if ( 97 <= c && c <= 122)
                        printf("%c", ((c - 97 + 13 ) % 26 )+ 97);
                else if ( 65 <= c && 90)
                        printf("%c", ((c - 65 + 13 ) % 26) + 65);
                else printf("%c",c);
        }
        return 0;
}

```

The program loops through the string provided as argument and does the following :

- checks if the current char is lowercase , if so we calculate its position in the alphabet `c - 97`.
- we add the offset , which is `13` in our case.
- we take the result `%26`, meaning that everytime we overflow, we get back to a valid alphabet position.
- then we add 97 to convert the result from the index to the character.

The same operations are valid for uppercase.

And if it is a number, we just print it.

Let's now compile our `rot13.c` program and execute it.

```bash
gcc -Wall -Wextra -Werror rot13.c -o rot13
./rot13 "Gur cnffjbeq vf WIAOOSFzMjXXBC0KoSKBbJ8puQm5lIEi"

```

![img](/../assets/bandit12-1.png)
![img](/../assets/bandit12-2.png)

We got our password ðŸ˜ƒ

> JVNBBFSmZwKKOP0XbFXOoW8chDz5yVRv

## Level 12 --> 13

### Level credentials

- username : **<span style="color : #277BE9">bandit12</span>**
- password : **<span style="color : #277BE9">JVNBBFSmZwKKOP0XbFXOoW8chDz5yVRv</span>**

### Level goal

The password for the next level is stored in the file data.txt, which is a hexdump of a file that has been repeatedly compressed. For this level it may be useful to create a directory under /tmp in which you can work using mkdir. For example: mkdir /tmp/myname123. Then copy the datafile using cp, and rename it using mv (read the manpages!)

### Level solution

![img](/../assets/bandit13.png)

We got our password ðŸ˜ƒ

> G7w8LIi6J3kTb8A7j9LgrywtEUlyyp6s
